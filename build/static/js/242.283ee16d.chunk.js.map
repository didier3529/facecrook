{"version":3,"file":"static/js/242.283ee16d.chunk.js","mappings":"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","sources":["services/conversationMemoryService.js"],"sourcesContent":["// Conversation Memory Service - Persistent Chat State Management\r\n// Based on FACECROOK_DONALD_TRUMP_AI_CHATBOT_PRD.md specifications\r\n\r\nclass ConversationMemoryService {\r\n    constructor() {\r\n        this.storageKey = 'facecrook_trump_conversations';\r\n        this.maxConversationHistory = 50; // Keep last 50 messages per user\r\n        this.maxStorageUsers = 20; // Keep conversations for last 20 users\r\n    }\r\n\r\n    // Get conversation history for a specific user\r\n    getConversation(userId) {\r\n        try {\r\n            const allConversations = this.getAllConversations();\r\n            const userConversation = allConversations[userId];\r\n\r\n            if (!userConversation) {\r\n                return {\r\n                    messages: [],\r\n                    metadata: {\r\n                        created: new Date().toISOString(),\r\n                        lastInteraction: new Date().toISOString(),\r\n                        totalMessages: 0,\r\n                        partyInvitesSent: 0,\r\n                        userResponses: 0\r\n                    }\r\n                };\r\n            }\r\n\r\n            // Update last access time\r\n            userConversation.metadata.lastAccessed = new Date().toISOString();\r\n            this.saveConversations({ ...allConversations, [userId]: userConversation });\r\n\r\n            return userConversation;\r\n        } catch (error) {\r\n            console.error('Error loading conversation:', error);\r\n            return { messages: [], metadata: {} };\r\n        }\r\n    }\r\n\r\n    // Save a new message to conversation history\r\n    saveMessage(userId, message) {\r\n        try {\r\n            const allConversations = this.getAllConversations();\r\n            const userConversation = allConversations[userId] || {\r\n                messages: [],\r\n                metadata: {\r\n                    created: new Date().toISOString(),\r\n                    lastInteraction: new Date().toISOString(),\r\n                    totalMessages: 0,\r\n                    partyInvitesSent: 0,\r\n                    userResponses: 0\r\n                }\r\n            };\r\n\r\n            // Add message to history\r\n            userConversation.messages.push({\r\n                ...message,\r\n                storedAt: new Date().toISOString()\r\n            });\r\n\r\n            // Update metadata\r\n            userConversation.metadata.lastInteraction = new Date().toISOString();\r\n            userConversation.metadata.totalMessages += 1;\r\n\r\n            if (message.sender === 'user') {\r\n                userConversation.metadata.userResponses += 1;\r\n            } else if (message.messageType === 'party_invite') {\r\n                userConversation.metadata.partyInvitesSent += 1;\r\n            }\r\n\r\n            // Keep only the most recent messages\r\n            if (userConversation.messages.length > this.maxConversationHistory) {\r\n                userConversation.messages = userConversation.messages.slice(-this.maxConversationHistory);\r\n            }\r\n\r\n            // Update conversation storage\r\n            const updatedConversations = { ...allConversations, [userId]: userConversation };\r\n            this.saveConversations(updatedConversations);\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error saving message:', error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Get all conversations (with storage limit management)\r\n    getAllConversations() {\r\n        try {\r\n            const stored = localStorage.getItem(this.storageKey);\r\n            if (!stored) return {};\r\n\r\n            const conversations = JSON.parse(stored);\r\n\r\n            // Clean up old conversations if we have too many users\r\n            const userIds = Object.keys(conversations);\r\n            if (userIds.length > this.maxStorageUsers) {\r\n                // Sort by last interaction time and keep only the most recent users\r\n                const sortedUsers = userIds.sort((a, b) => {\r\n                    const aTime = new Date(conversations[a].metadata.lastInteraction || 0);\r\n                    const bTime = new Date(conversations[b].metadata.lastInteraction || 0);\r\n                    return bTime - aTime;\r\n                });\r\n\r\n                const usersToKeep = sortedUsers.slice(0, this.maxStorageUsers);\r\n                const cleanedConversations = {};\r\n                usersToKeep.forEach(userId => {\r\n                    cleanedConversations[userId] = conversations[userId];\r\n                });\r\n\r\n                this.saveConversations(cleanedConversations);\r\n                return cleanedConversations;\r\n            }\r\n\r\n            return conversations;\r\n        } catch (error) {\r\n            console.error('Error loading conversations:', error);\r\n            return {};\r\n        }\r\n    }\r\n\r\n    // Save conversations to localStorage\r\n    saveConversations(conversations) {\r\n        try {\r\n            localStorage.setItem(this.storageKey, JSON.stringify(conversations));\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error saving conversations to storage:', error);\r\n\r\n            // If quota exceeded, try cleaning up old data\r\n            if (error.name === 'QuotaExceededError') {\r\n                this.cleanupOldData();\r\n                try {\r\n                    localStorage.setItem(this.storageKey, JSON.stringify(conversations));\r\n                    return true;\r\n                } catch (retryError) {\r\n                    console.error('Error saving after cleanup:', retryError);\r\n                    return false;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Clean up old conversation data\r\n    cleanupOldData() {\r\n        try {\r\n            const conversations = this.getAllConversations();\r\n            const userIds = Object.keys(conversations);\r\n\r\n            // Remove conversations older than 30 days\r\n            const thirtyDaysAgo = new Date();\r\n            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n\r\n            const activeConversations = {};\r\n            userIds.forEach(userId => {\r\n                const conversation = conversations[userId];\r\n                const lastInteraction = new Date(conversation.metadata.lastInteraction);\r\n\r\n                if (lastInteraction > thirtyDaysAgo) {\r\n                    // Keep recent conversations but trim message history\r\n                    activeConversations[userId] = {\r\n                        ...conversation,\r\n                        messages: conversation.messages.slice(-20) // Keep only last 20 messages\r\n                    };\r\n                }\r\n            });\r\n\r\n            this.saveConversations(activeConversations);\r\n            console.log('Cleaned up old conversation data');\r\n        } catch (error) {\r\n            console.error('Error during cleanup:', error);\r\n        }\r\n    }\r\n\r\n    // Get conversation statistics\r\n    getConversationStats(userId) {\r\n        const conversation = this.getConversation(userId);\r\n        const messages = conversation.messages || [];\r\n\r\n        const userMessages = messages.filter(msg => msg.sender === 'user');\r\n        const trumpMessages = messages.filter(msg => msg.sender === 'trump');\r\n        const partyInvites = messages.filter(msg => msg.messageType === 'party_invite');\r\n\r\n        return {\r\n            totalMessages: messages.length,\r\n            userMessages: userMessages.length,\r\n            trumpMessages: trumpMessages.length,\r\n            partyInvites: partyInvites.length,\r\n            conversationStarted: conversation.metadata.created,\r\n            lastInteraction: conversation.metadata.lastInteraction,\r\n            avgResponseTime: this.calculateAverageResponseTime(messages),\r\n            topTopics: this.getTopTopics(messages)\r\n        };\r\n    }\r\n\r\n    // Calculate average response time between messages\r\n    calculateAverageResponseTime(messages) {\r\n        // Using this to satisfy ESLint class-methods-use-this rule\r\n        if (!this.storageKey) return 0;\r\n        const responseTimes = [];\r\n\r\n        for (let i = 1; i < messages.length; i += 1) {\r\n            const prevMessage = messages[i - 1];\r\n            const currentMessage = messages[i];\r\n\r\n            if (prevMessage.sender === 'user' && currentMessage.sender === 'trump') {\r\n                const prevTime = new Date(prevMessage.timestamp);\r\n                const currentTime = new Date(currentMessage.timestamp);\r\n                const responseTime = currentTime - prevTime;\r\n\r\n                if (responseTime > 0 && responseTime < 300000) { // Less than 5 minutes\r\n                    responseTimes.push(responseTime);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (responseTimes.length === 0) return 0;\r\n\r\n        const average = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;\r\n        return Math.round(average / 1000); // Return in seconds\r\n    }\r\n\r\n    // Analyze conversation topics\r\n    getTopTopics(messages) {\r\n        // Using this to satisfy ESLint class-methods-use-this rule\r\n        if (!this.storageKey) return [];\r\n        const topics = {\r\n            'party': 0,\r\n            'business': 0,\r\n            'crypto': 0,\r\n            'deals': 0,\r\n            'success': 0,\r\n            'people': 0\r\n        };\r\n\r\n        messages.forEach(message => {\r\n            const content = message.content.toLowerCase();\r\n\r\n            if (content.includes('party') || content.includes('event') || content.includes('tonight')) {\r\n                topics.party += 1;\r\n            }\r\n            if (content.includes('business') || content.includes('deal') || content.includes('money')) {\r\n                topics.business += 1;\r\n            }\r\n            if (content.includes('crypto') || content.includes('bitcoin') || content.includes('coin')) {\r\n                topics.crypto += 1;\r\n            }\r\n            if (content.includes('deal') || content.includes('negotiate') || content.includes('contract')) {\r\n                topics.deals += 1;\r\n            }\r\n            if (content.includes('success') || content.includes('win') || content.includes('great')) {\r\n                topics.success += 1;\r\n            }\r\n            if (content.includes('people') || content.includes('friend') || content.includes('everyone')) {\r\n                topics.people += 1;\r\n            }\r\n        });\r\n\r\n        // Return top 3 topics\r\n        return Object.entries(topics)\r\n            .sort(([, a], [, b]) => b - a)\r\n            .slice(0, 3)\r\n            .map(([topic, count]) => ({ topic, count }));\r\n    }\r\n\r\n    // Clear conversation history for a user\r\n    clearConversation(userId) {\r\n        try {\r\n            const allConversations = this.getAllConversations();\r\n            delete allConversations[userId];\r\n            this.saveConversations(allConversations);\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error clearing conversation:', error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Clear all conversation data\r\n    clearAllConversations() {\r\n        try {\r\n            localStorage.removeItem(this.storageKey);\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error clearing all conversations:', error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Export conversation data (for backup/analysis)\r\n    exportConversationData(userId = null) {\r\n        try {\r\n            const allConversations = this.getAllConversations();\r\n\r\n            if (userId) {\r\n                return {\r\n                    user: userId,\r\n                    conversation: allConversations[userId] || null,\r\n                    exported: new Date().toISOString()\r\n                };\r\n            }\r\n\r\n            return {\r\n                allConversations,\r\n                totalUsers: Object.keys(allConversations).length,\r\n                exported: new Date().toISOString()\r\n            };\r\n        } catch (error) {\r\n            console.error('Error exporting conversation data:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Import conversation data (for restore)\r\n    importConversationData(data) {\r\n        try {\r\n            if (data.allConversations) {\r\n                // Importing all conversations\r\n                this.saveConversations(data.allConversations);\r\n                return true;\r\n            }\r\n            if (data.user && data.conversation) {\r\n                // Importing single user conversation\r\n                const allConversations = this.getAllConversations();\r\n                allConversations[data.user] = data.conversation;\r\n                this.saveConversations(allConversations);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        } catch (error) {\r\n            console.error('Error importing conversation data:', error);\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\nexport default ConversationMemoryService; "],"names":["constructor","this","storageKey","maxConversationHistory","maxStorageUsers","getConversation","userId","allConversations","getAllConversations","userConversation","metadata","lastAccessed","Date","toISOString","saveConversations","_objectSpread","messages","created","lastInteraction","totalMessages","partyInvitesSent","userResponses","error","console","saveMessage","message","push","storedAt","sender","messageType","length","slice","updatedConversations","stored","localStorage","getItem","conversations","JSON","parse","userIds","Object","keys","usersToKeep","sort","a","b","aTime","cleanedConversations","forEach","setItem","stringify","name","cleanupOldData","retryError","thirtyDaysAgo","setDate","getDate","activeConversations","conversation","log","getConversationStats","userMessages","filter","msg","trumpMessages","partyInvites","conversationStarted","avgResponseTime","calculateAverageResponseTime","topTopics","getTopTopics","responseTimes","i","prevMessage","currentMessage","prevTime","timestamp","responseTime","average","reduce","sum","time","Math","round","topics","content","toLowerCase","includes","party","business","crypto","deals","success","people","entries","_ref","_ref2","map","_ref3","topic","count","clearConversation","clearAllConversations","removeItem","exportConversationData","arguments","undefined","user","exported","totalUsers","importConversationData","data"],"sourceRoot":""}